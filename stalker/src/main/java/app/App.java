/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package app;

import app.LeaderUtils.QueueEntry;
import app.LeaderUtils.RequestAdministrator;
import app.chunk_utils.Indexer;
import app.chunk_utils.IndexFile;
import org.apache.commons.io.FilenameUtils;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Comparator;

public class App {

    public static void main(String[] args) {

        int leaderUuid = -1;

        //First thing to do is locate all other stalkers and print the stalkers to file

       DiscoveryManager DM = new DiscoveryManager(Module.STALKER);
       DM.start();

       // DiscoveryManager DM = new DiscoveryManager(Module.STALKER);
        //DM.start();

        int test = 0;
        initStalker();
        IndexFile ind = Indexer.loadFromFile();
        //ind.summary();
        System.out.println(NetworkUtils.timeStamp(1) + "Stalker Online");
        //testing


        //starting listener thread for health check and leader election
        Thread healthCheckthread = new Thread( new ListenerThread());
        healthCheckthread.start();



        //starting task for health checks on STALKERS and HARM targets
        String stalkerList = NetworkUtils.fileToString("config/stalkers.list");
        String harmlist = NetworkUtils.fileToString("config/harm.list");
        HealthChecker checker = new HealthChecker(NetworkUtils.mapFromJson(stalkerList),
                NetworkUtils.mapFromJson(harmlist));
        checker.startTask();

        // initiaze ids
        List<Integer> ids = NetworkUtils.mapToSList(NetworkUtils.mapFromJson(stalkerList));
        // Leader election by asking for a leader
        Thread Leaderchecker = new Thread( new LeaderCheck(NetworkUtils.mapFromJson(stalkerList),ids));
        Leaderchecker.start();
        leaderUuid = LeaderCheck.getLeaderUuid();



        while (true) {

            int role = ElectionUtils.identifyRole(ids);

            switch (role) {
                case 0:
                    //This means that this STK is the leader
                    //create a priority comparator for the Priority queue
                    Comparator<QueueEntry> entryPriorityComparator = new Comparator<QueueEntry>() {
                        @Override
                        public int compare(QueueEntry q1, QueueEntry q2) {
                            return q1.getPriority() - q2.getPriority();
                        }
                    };
                    PriorityQueue<QueueEntry> syncQueue = new PriorityQueue<>(entryPriorityComparator);

                StalkerRequestHandler stalkerCoordinator = new StalkerRequestHandler(syncQueue);
                RequestAdministrator reqAdmin = new RequestAdministrator(syncQueue);
                stalkerCoordinator.run();
                reqAdmin.run();
                break;
            case 1:
                JcpRequestHandler jcpRequestHandler = new JcpRequestHandler(ind);
                Thread jcpListener = new Thread(jcpRequestHandler);
                jcpListener.start();
                break;
            case 2:
                break;
        }
    }

    }



    //cleans chunk folders on startup
    public static void initStalker(){
        //clear chunk folder
        File chunk_folder = new File("temp/chunks/");

        File[] chunk_folder_contents = chunk_folder.listFiles();

        File temp_folder = new File("temp/toChunk/");
        File[] temp_folder_contents = temp_folder.listFiles();

        if(chunk_folder_contents != null) {
            for (File f : chunk_folder_contents) {
                if (!FilenameUtils.getExtension(f.getName()).equals("empty")) {
                    f.delete();
                }
            }
        }

        if(temp_folder_contents != null) {
            for (File f : temp_folder_contents) {
                if (!FilenameUtils.getExtension(f.getName()).equals("empty")) {
                    f.delete();
                }
            }
        }

    }


}

