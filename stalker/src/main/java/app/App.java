/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package app;

import app.LeaderUtils.CRUDQueue;
import app.LeaderUtils.LeaderCheck;
import app.LeaderUtils.RequestAdministrator;
import app.chunk_utils.Indexer;
import app.chunk_utils.IndexFile;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class App {


    private static int leaderUuid = -1;
    private static volatile IndexFile ind;
    public int getLeaderUuid()
    {
        return leaderUuid;
    }
    private static String stalker_path;
    private static String harm_path;
    private static int disc_timeout;
    private static int debug_mode = 3;
    private static ConfigFile cfg;

    public static void main(String[] args) {
        //debugging modes: 0 - none; 1 - message only; 2 - stack traces only; 3 - stack and message
        Debugger.setMode(3);
        Debugger.toggleFileMode();
        //make sure the directories are available
        initStalker();
        boolean running = false;

        ConfigManager.loadFromFile("config/config.cfg", "default", true);
        cfg = ConfigManager.getCurrent();
        loadConfig(cfg);
        ind = Indexer.loadFromFile();

        //starting listener thread for health check and leader election
        Thread listenerForHealth = new Thread( new ListenerThread(ind));
        listenerForHealth.start();
        Thread elecListen = new Thread(new ElectionListener());
        elecListen.start();

        //First thing to do is locate all other stalkers and print the stalkers to file
        //check the netDiscovery class to see where the file is being created
        Thread discManager = new Thread(new DiscoveryManager(Module.STALKER, disc_timeout, false));
        discManager.start();
        boolean connected = false;
        Debugger.log("Stalker Main: This Stalker's macID: " + NetworkUtils.getMacID() + "\n\n", null);
        Debugger.log("Stalker Main: Discovering nodes on network...", null);

        List<Integer> stalkerList = null;
        Map<Integer, NodeAttribute> harmlist = null;
        int attempts = 0;

        //wait for at least 2 connections
        while (!connected){
            //we will wait for network discovery to do its thing
            wait((disc_timeout * 1000) + 1000);
            try{
                stalkerList = NetworkUtils.getStalkerList(cfg.getStalker_list_path());
                harmlist = NetworkUtils.getNodeMap(cfg.getHarm_list_path());
            }
            catch (Exception e){
                //Debugger.log("", null);
            }

            Debugger.log("Debug 1", null);
            try{
                if (harmlist != null && !harmlist.isEmpty()){
                    Debugger.log("Populating harm list...", null);
                }
                else{
                    Debugger.log("Stalker Main: No HARM targets detected...", null);
                }
                LeaderCheck leaderchecker = new LeaderCheck();
                if(leaderchecker.tryLeader()){
                    connected = true;
                    running = true;
                    cfg = ConfigManager.getCurrent();
                    ind = Indexer.loadFromFile();
                    Debugger.log("Leader uuid = " + cfg.getLeader_id(), null);
                }
                if (stalkerList != null && stalkerList.size() >= cfg.getElection_threshold_s()){



                    if(stalkerList.size() >= cfg.getElection_threshold_s()){
                        connected = true;
                    }
                    Debugger.log("Threshold for initiation met...", null);
                }
                else{

                    Debugger.log("Stalker Main: No STALKERs detected yet...", null);
                    Debugger.log("Stalker Main: Waiting for servers to become available...", null);
                }
            }
            catch(NullPointerException e){
                Debugger.log("", e);
            }

            attempts++;
        }
//        Thread healthChecker = new Thread(new HealthChecker(Module.STALKER, null, true));
//        healthChecker.start();
        Debugger.log("Stalker Main: System discovery complete!", null);
        LeaderCheck leaderchecker = new LeaderCheck();

        //check if leader already found
        if(!running){
            //if not then start election
            leaderchecker.election(0);
            leaderUuid = LeaderCheck.getLeaderUuid();
            cfg.setLeader_id(leaderUuid);
            ConfigManager.saveToFile(cfg);
        }
        Thread elecListen2 = new Thread(new ElectionListener());
        elecListen2.start();
        while (true){
            //reelect
            //starting task for health checks on STALKERS and HARM targets

            HashMap<Integer, String> stalkermap = NetworkUtils.getStalkerMap(cfg.getStalker_list_path());
            stalkermap.remove(leaderUuid);
            int role = ElectionUtils.identifyRole(NetworkUtils.mapToSList(stalkermap),leaderUuid);
            cfg.setRole(role);
            ConfigManager.saveToFile(cfg);
            if (role != 0 && !running){
                //we kind of assume we'll get an indexfile from the leader
                while (true){
                    wait(3000);
                    if(getConfirmation(leaderUuid)){
                        break;
                    }
                }
            }

            switch (role){
                case 0:
                    Debugger.log("<<<<<<<-----Leader Online----->>>>>>> \n\n", null);
                    //This means that this STK is the leader
                    //create a priority comparator for the Priority queue
                    CRUDQueue syncQueue = new CRUDQueue();
                    Thread t1 = new Thread(new StalkerRequestHandler(syncQueue, ind));
                    Thread t2 =  new Thread(new RequestAdministrator(syncQueue));
                    t1.start();
                    t2.start();
                    //while no reelection is called
                    while(!ConfigManager.getCurrent().isReelection()){
                        //wait 10 seconds
                        wait(10000);
                    }
                    try{
                        t1.interrupt();
                        t2.interrupt();
                        t1.join();
                        t2.join();
                    }
                    catch(InterruptedException e){
                        Debugger.log("", e);
                    }
                    break;
                case 1:
                    Debugger.log("<<<<<<<-----Worker Online----->>>>>>>\n\n", null);
                    Thread jcpReq = new Thread(new JcpRequestHandler(ind));
                    jcpReq.start();
                    //while no reelection is called
                    while(!ConfigManager.getCurrent().isReelection()){
                        //wait 1 seconds
                        wait(1000);
                    }
                    //interrupt any workers
                    jcpReq.interrupt();
                    Debugger.log("Worker Interrupted", null);
                    try {
//                        healthChecker.interrupt();
//                        healthChecker.join();
                        jcpReq.join();
                    }
                    catch(InterruptedException e){
                        Debugger.log("", e);
                    }
                    break;
                case 2:
                    Debugger.log("<<<<<<<-----Vice Leader Online----->>>>>>>\n\n", null);
                    Thread vice = new Thread(new JcpRequestHandler(ind));
                    vice.start();
                    //while no reelection called
                    while(!ConfigManager.getCurrent().isReelection()){
                        //wait 10 seconds
                        wait(1000);
                    }
                    try {
                        //interrupt vice leader
                        vice.interrupt();
                        Debugger.log("Worker Interrupted", null);
//                        healthChecker.interrupt();
//                        healthChecker.join();
                        vice.join();
                    }
                    catch(InterruptedException e){
                        Debugger.log("", e);
                    }
                    break;
            }
            leaderchecker.election(1);
            leaderUuid = cfg.getLeader_id();
            cfg.setReelection(false);
            running = false;
            // Leader election by asking for a leader
        }


    }

    public static void loadConfig(ConfigFile cfg){
        disc_timeout = cfg.getStalker_update_freq();
        debug_mode = cfg.getDebug_mode();
        harm_path = cfg.getHarm_list_path();
        stalker_path = cfg.getStalker_list_path();
        Indexer.init(cfg.getIndex_file_path());
        NetworkUtils.loadConfig(cfg);
    }

    public static void initStalker(){
        List<File> directories = new ArrayList<>();
        directories.add(new File("temp"));
        directories.add(new File("logs"));
        directories.add(new File("index"));
        directories.add(new File("config"));
        directories.add(new File("index/index_file"));
        directories.add(new File("index/lists"));
        directories.add(new File("temp/chunks"));
        directories.add(new File("temp/toChunk"));
        directories.add(new File("temp/reassembled"));
        NetworkUtils.initDirs(directories, true, 5);
    }
    //will block worker from doing anythin until the leader is confirmed
    public static boolean getConfirmation(int uuid) {
        CommsHandler commLink = new CommsHandler();
        boolean success = false;
        while (!success) {
            try {
                Socket leader = NetworkUtils.createConnection(NetworkUtils.getStalkerMap(cfg.getStalker_list_path()).get(uuid), cfg.getLeader_report());
                if (leader != null) {
                    //get confirmation from leader
                    if (commLink.sendPacket(leader, MessageType.CONFIRM, "", true) == MessageType.CONFIRM) {
                        //get the indexfile from the leader
                        IndexFile temp = Indexer.fromString(commLink.receivePacket(leader).getMessage());
                        if (temp != null){
                            ind = temp;
                            Indexer.saveToFile(ind);
                            Debugger.log("Stalker Main: IndexFile synced with leader.", null);
                            Debugger.log("Stalker Main: Leader has granted permission to start!", null);
                            leader.close();
                            success = true;
                            return true;
                        }
                        else{
                            return false;
                        }
                    }
                } else {
                    wait(5000);
                }
            } catch (IOException e) {
                wait(5000);
                Debugger.log("", e);
            }

        }
        return true;
    }

    public static void wait(int millis){
        try{
            //wait for a bit
            Thread.sleep((long)((millis)));
        }
        catch (InterruptedException ex){
            Debugger.log("", ex);
        }
    }



}

